\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\makeatletter\@ifl@t@r\fmtversion{2018/04/01}{}{\usepackage[utf8]{inputenc}}\makeatother
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `eiger'}}
\par\bigskip{\large \today}
\end{center}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdftitle = {eiger: Run Phylogenetic Analyses Including Eigenvectors}}}{}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdfauthor = {Qifan Wang; Joshua Schraiber; Michael Edge; Matt Pennell}}}{}
\begin{description}
\raggedright{}
\item[Title]\AsIs{Run Phylogenetic Analyses Including Eigenvectors}
\item[Version]\AsIs{0.0.0.9000}
\item[Author]\AsIs{Qifan Wang [aut, cre], Joshua Schraiber [aut], Michael Edge [aut],
Matt Pennell [aut]}
\item[Maintainer]\AsIs{Qifan Wang }\email{qw64@cornell.edu}\AsIs{}
\item[Description]\AsIs{A package for incorporating eigenvectors of
variance-covariance matrices into phylogenetic analyses. Given a
phylogenetic tree, 'eiger' computes and visualizes the contributions
of the branches to the eigenvectors of some version of
variance-covariance matrix of the tree. If trait values are provided,
'eiger' can also run phylogenetic generalized least squares with
eigenvectors included as fixed effects to investigate whether the
traits are associated.}
\item[License]\AsIs{MIT + file LICENSE}
\item[Imports]\AsIs{ape, graphics, grDevices, phylolm, phytools, rlang, stats,
utils}
\item[Suggests]\AsIs{testthat (>= 3.0.0), TreeSim, withr}
\item[Config/testthat/edition]\AsIs{3}
\item[Encoding]\AsIs{UTF-8}
\item[Roxygen]\AsIs{list(markdown = TRUE)}
\item[RoxygenNote]\AsIs{7.3.3}
\end{description}
\Rdcontents{Contents}
\HeaderA{add\_axis}{Add axis to the color bar}{add.Rul.axis}
\keyword{internal}{add\_axis}
%
\begin{Description}
\code{add\_axis()} adds an axis to the color bar.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
add_axis(side = 4, cex.axis = 1.5, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{side}] See \LinkA{graphics::axis}{graphics::axis}. Default to \code{4}.

\item[\code{cex.axis}] See \LinkA{graphics::axis}{graphics::axis}. Default to \code{1.5}.

\item[\code{...}] Additional parameters passed to \LinkA{graphics::axis}{graphics::axis}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
No value, but produces the side effect of adding an axis to the
color bar.
\end{Value}
\HeaderA{add\_colorbar}{Add color bar to the plot}{add.Rul.colorbar}
\keyword{internal}{add\_colorbar}
%
\begin{Description}
\code{add\_colorbar()} adds a color bar to the plot.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
add_colorbar(
  color_breaks,
  color_palette,
  dim,
  text_args = list(),
  axis_args = list(),
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{color\_breaks}] A string vector representing the boundaries of value
intervals so that values falling in the same interval have the same color.

\item[\code{color\_palette}] A string vector representing the color palette for the
color bar.

\item[\code{dim}] An integer representing the dimension of eigenvector for plotting.

\item[\code{text\_args}] A named list of arguments passed to an internal helper that
adds title text to the color bar. Elements include:
\begin{description}

\item[side] See \LinkA{graphics::mtext}{graphics::mtext}. Default to \code{4}.
\item[line] See \LinkA{graphics::mtext}{graphics::mtext}. Default to \code{5}.
\item[cex] See \LinkA{graphics::mtext}{graphics::mtext}. Default to \code{1.5}.
\item[...] Additional parameters passed to \LinkA{graphics::mtext}{graphics::mtext}.

\end{description}


\item[\code{axis\_args}] A named list of arguments passed to an internal helper that
adds axis to the color bar.
\begin{description}

\item[side] See \LinkA{graphics::axis}{graphics::axis}. Default to \code{4}.
\item[cex.axis] See \LinkA{graphics::axis}{graphics::axis}. Default to \code{1.5}.
\item[...] Additional parameters passed to \LinkA{graphics::axis}{graphics::axis}.

\end{description}


\item[\code{...}] Parameters passed to \LinkA{graphics::image}{graphics::image}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
No value, but produces the side effect of adding a color bar to the
plot.
\end{Value}
\HeaderA{add\_text}{Add title text to the color bar}{add.Rul.text}
\keyword{internal}{add\_text}
%
\begin{Description}
\code{add\_text()} adds a title text to the color bar.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
add_text(dim, side = 4, line = 5, cex = 1.5, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dim}] An integer representing the dimension of eigenvector for plotting.

\item[\code{side}] See \LinkA{graphics::mtext}{graphics::mtext}. Default to \code{4}.

\item[\code{line}] See \LinkA{graphics::mtext}{graphics::mtext}. Default to \code{5}.

\item[\code{cex}] See \LinkA{graphics::mtext}{graphics::mtext}. Default to \code{1.5}.

\item[\code{...}] Additional parameters passed to \LinkA{graphics::mtext}{graphics::mtext}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
No value, but produces the side effect of writing the title text
into the color bar.
\end{Value}
\HeaderA{check\_dimensions}{Check if the input dimensions are integers between some lower and upper bound}{check.Rul.dimensions}
\keyword{internal}{check\_dimensions}
%
\begin{Description}
\code{check\_dimensions()} checks if each of the input dimensions is an integer
between some lower bound and some upper bound.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_dimensions(x, low, high)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An integer or a vector of integers for the input dimensions.

\item[\code{low}] An integer for the lower bound of the dimensions.

\item[\code{high}] An integer for the upper bound of the dimensions.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisible returns \code{NULL} if each of the input dimensions is an
integer between some lower bound and some upper bound, otherwise raises an
error.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
check_dimensions(1, 1, 5)
check_dimensions(1:9, 1, 10)
check_dimensions(c(5, 4, 9, 8, 1, 3), 1, 10)
try(check_dimensions(-7, 1, 10))
try(check_dimensions(0, 1, 8))
try(check_dimensions(c(3, 2, 11, 4, 6), 1, 8))
try(check_dimensions(c(0.5, 2, 1, 8), 1, 8))

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{check\_eiger}{Check if the data are compatible for running eiger regression.}{check.Rul.eiger}
\keyword{internal}{check\_eiger}
%
\begin{Description}
\code{check\_eiger()} checks if the trait values, the phylogenetic tree, and the
number of eigenvectors to include in the regression are compatible with each
other.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_eiger(x, y, tree, n_eigenvectors)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A vector of numeric values representing the predictor trait values
of the \code{n} tips in the tree.

\item[\code{y}] A vector of numeric values representing the outcome trait values of
the \code{n} tips in the tree.

\item[\code{tree}] A phylogenetic tree as a valid object of class \code{"phylo"}.

\item[\code{n\_eigenvectors}] The number of eigenvectors to include as fixed effects
in eiger regression.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisible returns \code{NULL} if all the following requirements are met:
\begin{itemize}

\item{} The input \code{tree} is a valid object of class \code{"phylo"},
\item{} The input \code{tree} has all branch lengths defined and non-negative,
\item{} The input \code{tree} has all unique tip labels,
\item{} \code{n\_eigenvectors} is less than or equal to the number of tips in \code{tree} and greater than to equal to \code{0},
\item{} \code{x} and \code{y} are vectors of numeric values,
\item{} The lengths of \code{x} and \code{y} are equal to the number of tips in \code{tree}.
Otherwise raises an error.

\end{itemize}

\end{Value}
\HeaderA{check\_phylo}{Check if an object is a valid \code{"Phylo"} object}{check.Rul.phylo}
\keyword{internal}{check\_phylo}
%
\begin{Description}
\code{check\_phylo()} checks if an object is a valid object of class \code{"Phylo"}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_phylo(tree)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{tree}] A phylogenetic tree as an object of class \code{"phylo"}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisible returns \code{NULL} if the phylogenetic tree is a valid object
of class \code{"phylo"}, otherwise raises an error.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
set.seed(42)
yule_tree <- TreeSim::sim.bd.taxa(10, 1, 1, 0, 1, complete = FALSE)[[1]]
check_phylo(yule_tree)
broken_tree <- list(edge = matrix(1:4, 2, 2), tip.label = letters[1:3])
try(check_phylo(broken_tree))

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{check\_phylo\_branches}{Check if a \code{"Phylo"} object has valid branch lengths}{check.Rul.phylo.Rul.branches}
\keyword{internal}{check\_phylo\_branches}
%
\begin{Description}
\code{check\_phylo\_branches()} checks if a \code{"Phylo"} object has defined lengths for
all its branches and if the branch lengths are all non-negative.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_phylo_branches(tree)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{tree}] A phylogenetic tree as a valid object of class \code{"phylo"}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisible returns \code{NULL} if the phylogenetic tree has defined
non-negative lengths for all its branches, otherwise raises an error.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
set.seed(42)
yule_tree <- TreeSim::sim.bd.taxa(10, 1, 1, 0, 1, complete = FALSE)[[1]]
check_phylo_branches(yule_tree)

# Input tree must have all the branch lengths defined and non-negative
broken_tree <- list(edge = matrix(c(4, 1, 4, 5, 5, 2, 5, 3), 4, 2, byrow = TRUE),
                    tip.label = letters[1:3],
                    Nnode = 2)
class(broken_tree) <- "phylo"
try(check_phylo_branches(broken_tree))
broken_tree$edge.length <- c(1, 2)
try(check_phylo_branches(broken_tree))
broken_tree$edge.length <- c(1, 2, NA, 1)
try(check_phylo_branches(broken_tree))
broken_tree$edge.length <- c(1, 2, -1, 1)
try(check_phylo_branches(broken_tree, "vcv", 2))

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{check\_plotting\_data}{Check if the data for plotting is valid}{check.Rul.plotting.Rul.data}
\keyword{internal}{check\_plotting\_data}
%
\begin{Description}
\code{check\_plotting\_data()} checks if the data frame for branch contributions is
consistent with the phylogenetic tree and if the dimension for plotting is
included in the data frame.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_plotting_data(tree, branch_contributions, dim)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{tree}] A phylogenetic tree as an object of class \code{"phylo"}.

\item[\code{branch\_contributions}] A data frame representing the contributions of
branches of the phylogenetic tree to the eigenvectors of some version of
variance-covariance matrix for the whole tree. The data frame of should
have \code{m} rows and \code{n} columns, where \code{m} is the number of branches, and \code{n}
is the number of dimensions of eigenvectors for which the branch
contributions are computed.

\item[\code{dim}] The dimension of eigenvector to plot.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisible returns \code{NULL} if all the following requirements are met:
\begin{itemize}

\item{} The data frame for branch contributions has the same number of rows as
the number of branches in the tree.
\item{} The data frame for branch contributions has the column names representing
the dimensions of eigenvectors that are less than the number of tips in the
tree.
\item{} The dimension for plotting is included in the data frame for branch
contributions.
Otherwise raises an error.

\end{itemize}

\end{Value}
\HeaderA{compute\_branch\_contributions}{Compute branch contributions to eigenvectors of variance-covariance matrices}{compute.Rul.branch.Rul.contributions}
%
\begin{Description}
\code{compute\_branch\_contributions()} computes the contributions of each branch of
a phylogenetic tree to the eigenvectors of some version of
variance-covariance matrix for the whole tree.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
compute_branch_contributions(
  tree,
  cov_matrix = c("dcvcv", "vcv", "egrm"),
  dims
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{tree}] A phylogenetic tree as an object of class \code{"phylo"} with all the
branch lengths defined and non-negative.

\item[\code{cov\_matrix}] A string representing the way to calculate the
variance-covariance matrices. The options are \code{"dcvcv"} (double-centered
phylogenetic variance-covariance matrix), \code{"vcv"} (non-centered
phylogenetic variance-covariance matrix), and \code{"egrm"} (expected genetic
relatedness matrix). Default to \code{"dcvcv"}.

\item[\code{dims}] An integer or a vector of integers for the dimensions of
eigenvectors to compute the branch contributions.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame of \code{m} rows and \code{n} columns, where \code{m} is the number of
branches, and \code{n} is the number of dimensions of eigenvectors to compute
the branch contributions. The \code{i}-th row corresponds to the contributions
of the \code{i}-th branch to the eigenvectors, and the \code{j}-th column has name
\code{"dim\_k"}, where \code{k} is the . The last column refers to where \code{k} is the
\code{j}-th dimension in \code{dims} to compute the branch contributions. Raises
error if the input tree is not a valid tree of class \code{"phylo"} or if not
all the branch lengths are defined or if some branch lengths are negative.
Also raises error if the input dimensions contain either non-integers or
integers less than \code{1} or greater than the number of tips in the tree.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
set.seed(42)
yule_tree <- TreeSim::sim.bd.taxa(10, 1, 1, 0, 1, complete = FALSE)[[1]]
compute_branch_contributions(yule_tree, "vcv", 1)
compute_branch_contributions(yule_tree, "egrm", 3)
compute_branch_contributions(yule_tree, "dcvcv", 1:5)
compute_branch_contributions(yule_tree, dims = c(2, 4, 6, 7))

# Input tree must be a valid object of class "phylo"
broken_tree <- list(edge = matrix(1:4, 2, 2), tip.label = letters[1:3])
try(compute_branch_contributions(broken_tree, "vcv", 2))

# Input tree must have all the branch lengths defined and non-negative
broken_tree <- list(edge = matrix(c(4, 1, 4, 5, 5, 2, 5, 3), 4, 2, byrow = TRUE),
                    tip.label = letters[1:3],
                    Nnode = 2)
class(broken_tree) <- "phylo"
try(compute_branch_contributions(broken_tree, "vcv", 2))
broken_tree$edge.length <- c(1, 2)
try(compute_branch_contributions(broken_tree, "vcv", 2))
broken_tree$edge.length <- c(1, 2, NA, 1)
try(compute_branch_contributions(broken_tree, "vcv", 2))
broken_tree$edge.length <- c(1, 2, -1, 1)
try(compute_branch_contributions(broken_tree, "vcv", 2))

# Input dimensions must all be integers from 1 to the number of tips in the tree
try(compute_branch_contributions(yule_tree, "vcv", 11))
try(compute_branch_contributions(yule_tree, "dcvcv", c(8, 9, 2, 14, 1)))

\end{ExampleCode}
\end{Examples}
\HeaderA{compute\_branch\_egrm}{Construct the expected genetic relatedness matrix for a branch}{compute.Rul.branch.Rul.egrm}
\keyword{internal}{compute\_branch\_egrm}
%
\begin{Description}
\code{compute\_branch\_egrm()} computes the expected genetic relatedness matrix for
a branch of a phylogenetic tree.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
compute_branch_egrm(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A binary vector for the descendancy relationships between the tips
and the branch. An entry is \code{1} if the corresponding tip is a descendant of
the branch cocnerned and \code{0} otherwise.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The expected genetic variance-covariance matrix for the branch. An
entry in the matrix is positive if the two tips corresponding to the row
and the column are both descendants or non-descendants of the branch, and
negative if one tip is a descendant and the other is not. The exact values
depend on the partition of all the tips into descendants and
non-descendants.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
compute_branch_egrm(c(1, 0, 0, 1, 1))

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{compute\_branch\_vcv}{Construct the variance-covariance matrix for a branch}{compute.Rul.branch.Rul.vcv}
\keyword{internal}{compute\_branch\_vcv}
%
\begin{Description}
\code{compute\_branch\_vcv()} computes the variance-covariance matrix for a branch
of a phylogenetic tree. An entry in the matrix is \code{1} if the two tips
corresponding to the row and the column are both descendants of the branch,
and \code{0} otherwise.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
compute_branch_vcv(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A binary vector for the descendancy relationships between the tips
and the branch. An entry is \code{1} if the corresponding tip is a descendant of
the branch cocnerned and \code{0} otherwise.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A binary variance-covariance matrix for the branch. An entry in the
matrix is \code{1} if the two tips corresponding to the row and the column are
both descendants of the branch, and \code{0} otherwise.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
compute_branch_vcv(c(1, 0, 0, 1, 1))

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{compute\_cov\_matrices}{Construct variance-covariance matrices for a tree and each of its branches}{compute.Rul.cov.Rul.matrices}
\keyword{internal}{compute\_cov\_matrices}
%
\begin{Description}
\code{compute\_cov\_matrices()} computes some version of variance-covariance matrix
for a phylogenetic tree as well as for each of its branches.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
compute_cov_matrices(tree, cov_matrix = c("dcvcv", "vcv", "egrm"))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{tree}] A phylogenetic tree as an object of class \code{"phylo"} with all the
branch lengths defined and non-negative.

\item[\code{cov\_matrix}] A string representing the way to calculate the
variance-covariance matrices. The options are \code{"dcvcv"} (double-centered
phylogenetic variance-covariance matrix), \code{"vcv"} (non-centered
phylogenetic variance-covariance matrix), and \code{"egrm"} (expected genetic
relatedness matrix). Default to \code{"dcvcv"}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of two values.

The first value \code{cov\_matrices} is an \code{n\textasciicircum{}2} by \code{(m + 1)} dataframe, where
\code{n} is the number of tips in the phylogenetic tree and \code{m} is the number of
branches. The first \code{m} columns refer to the variance-covariance matrices
for the corresponding branches in the tree. The \code{k}-th of the first \code{m}
columns has name \code{"dcvcv\_k"}, \code{"vcv\_k"}, or \code{"egrm\_k"} depending on the way
the variance-covariance matrices are calculated. The last column refers to
the variance-covariance matrix for the whole tree and has name
\code{"dcvcv\_tot"}, \code{"vcv\_tot"}, or \code{"egrm\_tot"}. The matrices are collapsed
into vectors for easier visualization and downstream analyses.

The second value \code{cov\_matrix\_tree} is the variance-covariance matrix for
the whole phylogenetic tree.

Raises error if the input is not a valid tree of class \code{"phylo"} or if not
all the branch lengths are defined or if some branch lengths are negative.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
set.seed(42)
yule_tree <- TreeSim::sim.bd.taxa(10, 1, 1, 0, 1, complete = FALSE)[[1]]
compute_cov_matrices(yule_tree)
compute_cov_matrices(yule_tree, cov_matrix = "egrm")

# Input tree must be a valid object of class "phylo"
broken_tree <- list(edge = matrix(1:4, 2, 2), tip.label = letters[1:3])
try(compute_cov_matrices(broken_tree))

# Input tree must have all the branch lengths defined and non-negative
broken_tree <- list(edge = matrix(c(4, 1, 4, 5, 5, 2, 5, 3), 4, 2, byrow = TRUE),
                    tip.label = letters[1:3],
                    Nnode = 2)
class(broken_tree) <- "phylo"
try(compute_cov_matrices(broken_tree))
broken_tree$edge.length <- c(1, 2)
try(compute_cov_matrices(broken_tree))
broken_tree$edge.length <- c(1, 2, NA, 1)
try(compute_cov_matrices(broken_tree))
broken_tree$edge.length <- c(1, 2, -1, 1)
try(compute_branch_contributions(broken_tree, "vcv", 2))

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{compute\_descendancy\_matrix}{Calculate the descendancy matrix for branches of a tree}{compute.Rul.descendancy.Rul.matrix}
\keyword{internal}{compute\_descendancy\_matrix}
%
\begin{Description}
\code{compute\_descendancy\_matrix()} computes a binary matrix for descendancy
relationships between branches and tips of a tree, with an entry being \code{1} if
the corresponding tip (column) is a descendant of the corresponding branch
(row) and \code{0} otherwise.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
compute_descendancy_matrix(tree)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{tree}] A phylogenetic tree as an object of class \code{"phylo"}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A binary descendancy matrix with each row representing a branch of
the tree and each column a tip of the tree. An entry of the matrix is \code{1}
if the corresponding tip (column) is a descendant of the corresponding
branch (row) and \code{0} otherwise. Raises error if the input is not a valid
tree of class \code{"phylo"}.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
set.seed(42)
yule_tree <- TreeSim::sim.bd.taxa(10, 1, 1, 0, 1, complete = FALSE)[[1]]
compute_descendancy_matrix(yule_tree)

# Input must be a valid object of class "phylo"
broken_tree <- list(edge = matrix(1:4, 2, 2), tip.label = letters[1:3])
try(compute_descendancy_matrix(broken_tree))

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{create\_color\_palette}{Create a color palette from a color-generating function or a set of colors}{create.Rul.color.Rul.palette}
\keyword{internal}{create\_color\_palette}
%
\begin{Description}
\code{create\_color\_palette()} creates a new color palette by extracting colors
from from a color-generating function or interpolating a set of given colors.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
create_color_palette(color_scheme = NULL, n_colors = 100)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{color\_scheme}] A string representing a color-generating function or
vector of strings representing the set of colors to interpolate to create
the new palette. Default to \code{NULL}.

\item[\code{n\_colors}] An integer representing the number of colors in the color
palette. Default to \code{100}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of strings representing the set of colors in the new color
palette. Raises error if the name of the color-generating function is not
valid or if the list of colors provided are not valid.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
create_color_palette(c("red", "blue"), 30)
create_color_palette(c("#BBCCEE", "#CCEEFF", "#CCDDAA", "#EEEEBB", "#FFCCCC"), 50)
create_color_palette("Viridis", 80)
try(create_color_palette("red", 30))
try(create_color_palette(c("apple", "blueberry"), 30))
try(create_color_palette(c("red", "blue"), 3.14))
try(create_color_palette("CoolColors", 80))

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{get\_default\_colors}{Create the default list of colors}{get.Rul.default.Rul.colors}
\keyword{internal}{get\_default\_colors}
%
\begin{Description}
\code{get\_default\_colors()} creates the default list of colors for downstream
plotting.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_default_colors()
\end{verbatim}
\end{Usage}
%
\begin{Value}
A vector of strings representing colors from dark blue to light blue
to orange to dark red.
\end{Value}
\HeaderA{map\_colors}{Map a vector of values to colors in the color palette}{map.Rul.colors}
\keyword{internal}{map\_colors}
%
\begin{Description}
\code{map\_colors()} maps a vector of values to colors in the color palette. The
mapping is performed in a way such that the values close to \code{0} would be
mapped to colors in the middle of the color palette. Depending on the
distribution of the values, the first or the last color in the color palette
might not necessarily have a value being mapped to.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
map_colors(x, color_palette)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A vector of values to be mapped to colors.

\item[\code{color\_palette}] A list of strings representing the color palette for
mapping.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of two values.

The first value \code{color\_breaks} is a vector representing the boundaries of
value intervals so that values falling in the same interval would be
assigned the same color.

The second value \code{mapped\_colors} is a vector of strings representing the
colors each value is mapped to.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
map_colors(-8:8, c("blue", "red"))
x <- c(-3.5, 9.8, 0.3, -1.1, -4.6, 2.1)
color_palette <- c("#BBCCEE", "#CCEEFF", "#CCDDAA", "#EEEEBB", "#FFCCCC")
map_colors(x, color_palette)

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{plot\_branch\_contributions}{Plot branch contributions to an eigenvector of variance-covariance matrices}{plot.Rul.branch.Rul.contributions}
%
\begin{Description}
\code{plot\_branch\_contributions()} plots the contributions of branches of a
phylogenetic tree to some eigenvector using some version of
variance-covariance matrix for the whole tree.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_branch_contributions(
  tree,
  branch_contributions = NULL,
  cov_matrix = c("dcvcv", "vcv", "egrm"),
  dim,
  text_args = list(),
  axis_args = list(),
  colorbar_args = list(),
  color_scheme = NULL,
  n_colors = 100,
  edge.width = 5,
  show.tip.label = FALSE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{tree}] A phylogenetic tree as an object of class \code{"phylo"}.

\item[\code{branch\_contributions}] A data frame representing the contributions of
branches of the phylogenetic tree to the eigenvectors of some version of
variance-covariance matrix for the whole tree. The data frame of should
have \code{m} rows and \code{n} columns, where \code{m} is the number of branches, and \code{n}
is the number of dimensions of eigenvectors for which the branch
contributions are computed. Default to \code{NULL}, in which case
\code{branch\_contributions} will be calculated using \code{cov\_matrix}.

\item[\code{cov\_matrix}] A string representing the version of variance-covariance
matrix used to obtain the data frame \code{branch\_contributions}. The options
are \code{"dcvcv"} (double-centered phylogenetic variance-covariance matrix),
\code{"vcv"} (non-centered phylogenetic variance-covariance matrix), and
\code{"egrm"} (expected genetic relatedness matrix). If \code{branch\_contributions}
is \code{NULL}, \code{cov\_matrix} is used to calculate \code{branch\_contributions}.
Default to \code{"dcvcv"}.

\item[\code{dim}] The dimension of eigenvector to plot.

\item[\code{text\_args}] A named list of arguments passed to an internal helper that
adds title text to the color bar. Elements include:
\begin{description}

\item[side] See \LinkA{graphics::mtext}{graphics::mtext}. Default to \code{4}.
\item[line] See \LinkA{graphics::mtext}{graphics::mtext}. Default to \code{5}.
\item[cex] See \LinkA{graphics::mtext}{graphics::mtext}. Default to \code{1.5}.
\item[...] Additional parameters passed to \LinkA{graphics::mtext}{graphics::mtext}.

\end{description}


\item[\code{axis\_args}] A named list of arguments passed to an internal helper that
adds axis to the color bar.
\begin{description}

\item[side] See \LinkA{graphics::axis}{graphics::axis}. Default to \code{4}.
\item[cex.axis] See \LinkA{graphics::axis}{graphics::axis}. Default to \code{1.5}.
\item[...] Additional parameters passed to \LinkA{graphics::axis}{graphics::axis}.

\end{description}


\item[\code{colorbar\_args}] Parameters passed to \LinkA{graphics::image}{graphics::image} for making the
color bar.

\item[\code{color\_scheme}] A string representing a color-generating function or
vector of strings representing the set of colors to interpolate to create
the new palette. Default to \code{NULL}.

\item[\code{n\_colors}] An integer representing the number of colors in the color
palette. Default to \code{100}.

\item[\code{edge.width}] See \LinkA{ape::plot.phylo}{ape::plot.phylo}. Default to \code{5}.

\item[\code{show.tip.label}] See \LinkA{ape::plot.phylo}{ape::plot.phylo}. Default to \code{FALSE}.

\item[\code{...}] Other parameters passed to \LinkA{ape::plot.phylo}{ape::plot.phylo}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
No value, but produces the side effect of plotting the contributions
of branches of a phylogenetic tree to the eigenvector of dimension \code{dim}
using some version of variance-covariance matrix for the whole tree. A
color bar is also included with the plot.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
set.seed(42)
yule_tree <- TreeSim::sim.bd.taxa(20, 1, 1, 0, 1, complete = FALSE)[[1]]
df <- compute_branch_contributions(yule_tree, "egrm", 1:10)
plot_branch_contributions(yule_tree, df, "egrm", 3)
plot_branch_contributions(yule_tree, df, "egrm", 5, n_colors = 50)
plot_branch_contributions(yule_tree, cov_matrix = "dcvcv", dim = 5, n_colors = 80)

\end{ExampleCode}
\end{Examples}
\HeaderA{prepare\_eiger}{Prepare the data frame for running eiger regression}{prepare.Rul.eiger}
%
\begin{Description}
\code{prepare\_eiger()} constructs a data frame that is essential for running eiger
regression. The data frame includes the original data for the two traits as
well as the eigenvectors of the variance-covariance matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
prepare_eiger(x, y, tree, n_eigenvectors, dc = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A vector of numeric values representing the predictor trait values
of the \code{n} tips in the tree.

\item[\code{y}] A vector of numeric values representing the outcome trait values of
the \code{n} tips in the tree.

\item[\code{tree}] A phylogenetic tree as a valid object of class \code{"phylo"}.

\item[\code{n\_eigenvectors}] The number of eigenvectors to include as fixed effects
in eiger regression.

\item[\code{dc}] A boolean value. \code{TRUE} if the eigenvectors need to be calculated
from double-centered variance-covariance matrix and \code{FALSE} otherwise.
Default to \code{FALSE}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame of \code{n} rows and \code{(n + 2)} columns, where \code{n} is the
number of tips in the tree. The first two columns have names \code{X} and \code{Y},
representing the trait values. The next \code{n} columns represent the \code{n}
eigenvectors of the variance-covariance matrix. Raises error if:
\begin{itemize}

\item{} The input \code{tree} is not a valid object of class \code{"phylo"},
\item{} The input \code{tree} does not have all branch lengths defined or have some of them being negative,
\item{} The input \code{tree} does not have all unique tip labels,
\item{} \code{n\_eigenvectors} is greater than the number of tips in \code{tree},
\item{} \code{x} and \code{y} are not vectors of numeric values,
\item{} The lengths of \code{x} and \code{y} are not equal to the number of tips in \code{tree}.

\end{itemize}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
set.seed(42)
yule_tree <- TreeSim::sim.bd.taxa(100, 1, 1, 0, 1, complete = FALSE)[[1]]
BM <- phytools::fastBM(yule_tree, 1, nsim = 2)
x <- BM[, 1]
y <- BM[, 2]
prepare_eiger(x, y, yule_tree, 20)
prepare_eiger(x, y, yule_tree, 30, TRUE)

\end{ExampleCode}
\end{Examples}
\HeaderA{run\_eiger}{Run eiger regression}{run.Rul.eiger}
%
\begin{Description}
\code{run\_eiger()} runs the eiger regression, which includes eigenvectors of the
variance-covariance matrix of a phylogenetic tree as fixed effects in
\code{phylolm}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
run_eiger(
  x,
  y,
  tree,
  n_eigenvectors,
  dc = FALSE,
  df = NULL,
  intercept = TRUE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A vector of numeric values representing the predictor trait values
of the \code{n} tips in the tree.

\item[\code{y}] A vector of numeric values representing the outcome trait values of
the \code{n} tips in the tree.

\item[\code{tree}] A phylogenetic tree as a valid object of class \code{"phylo"}.

\item[\code{n\_eigenvectors}] The number of eigenvectors to include as fixed effects
in eiger regression.

\item[\code{dc}] A boolean value. \code{TRUE} if the eigenvectors need to be calculated
from double-centered variance-covariance matrix and \code{FALSE} otherwise.
Default to \code{FALSE}.

\item[\code{df}] A data frame of \code{n} rows and \code{(n + 2)} columns, where \code{n} is the
number of tips in the tree. The first two columns have names \code{X} and \code{Y},
representing the trait values. The next \code{n} columns represent the \code{n}
eigenvectors of the variance-covariance matrix. Default to \code{NULL}, in which
case \code{df} will be computed from the other parameters.

\item[\code{intercept}] A boolean. \code{TRUE} if the intercept is included in the
regression, otherwise \code{FALSE}. Default to \code{TRUE}.

\item[\code{...}] Other parameters passed to \LinkA{phylolm::phylolm}{phylolm::phylolm}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The results of eiger regession, which is the same as the return
values of \LinkA{phylolm::phylolm}{phylolm::phylolm}. Raises error if:
\begin{itemize}

\item{} The input \code{tree} is not a valid object of class \code{"phylo"},
\item{} The input \code{tree} does not have all branch lengths defined or have some of them being negative,
\item{} The input \code{tree} does not have all unique tip labels,
\item{} \code{n\_eigenvectors} is greater than the number of tips in \code{tree},
\item{} \code{x} and \code{y} are not vectors of numeric values,
\item{} The lengths of \code{x} and \code{y} are not equal to the number of tips in \code{tree},
\item{} \code{n\_eigenvectors} is too large (even though it's valid),
\item{} Other problems when running \LinkA{phylolm::phylolm}{phylolm::phylolm}.

\end{itemize}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
set.seed(42)
yule_tree <- TreeSim::sim.bd.taxa(100, 1, 1, 0, 1, complete = FALSE)[[1]]
BM <- phytools::fastBM(yule_tree, 1, nsim = 2)
x <- BM[, 1]
y <- BM[, 2]
run_eiger(x, y, yule_tree, n_eigenvectors = 20)
run_eiger(x, y, yule_tree, 30, dc = TRUE, intercept = FALSE)

\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
